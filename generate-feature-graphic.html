<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Generate TempoFlow Feature Graphic</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #1a1a1a;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    #canvas {
      border: 2px solid #008080;
      background: transparent;
      max-width: 100%;
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      background: #008080;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    button:hover {
      background: #00a0a0;
    }
    .info {
      font-size: 14px;
      color: #888;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>TempoFlow Feature Graphic Generator</h1>
  <p class="info">Google Play Store Feature Graphic: 1024 x 500 pixels</p>
  <canvas id="canvas" width="1024" height="500"></canvas>
  
  <button id="download">Download Feature Graphic (1024x500 PNG)</button>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Modern gradient colors
    const bgDark = '#1e1e2e';
    const purple = '#a855f7';
    const cyan = '#06b6d4';
    const pink = '#ec4899';
    
    function drawFeatureGraphic() {
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      
      // Modern dark gradient background
      const bgGrad = ctx.createLinearGradient(0, 0, w, h);
      bgGrad.addColorStop(0, '#1a1a2e');
      bgGrad.addColorStop(0.5, '#16213e');
      bgGrad.addColorStop(1, '#0f1419');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, w, h);
      
      // Left side: Musical elements
      const noteX = w * 0.18;
      const noteY = h * 0.5;
      const noteRadius = h * 0.12;
      
      // Glow behind elements
      const glowGrad = ctx.createRadialGradient(noteX, noteY - noteRadius, 0, noteX, noteY - noteRadius, h * 0.6);
      glowGrad.addColorStop(0, 'rgba(168, 85, 247, 0.2)');
      glowGrad.addColorStop(0.5, 'rgba(6, 182, 212, 0.15)');
      glowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = glowGrad;
      ctx.beginPath();
      ctx.arc(noteX, noteY - noteRadius, h * 0.6, 0, Math.PI * 2);
      ctx.fill();
      
      // Musical note
      drawGlossyNote(ctx, noteX - w * 0.03, noteY, noteRadius, h * 0.35, purple, '#e0bbff');
      
      // Smaller note
      drawGlossyNote(ctx, noteX + w * 0.04, noteY - h * 0.15, noteRadius * 0.75, h * 0.25, cyan, '#d0f4ff');
      
      // Metronome stick
      drawMetronomeStick(ctx, noteX + w * 0.08, noteY - h * 0.05, h * 0.3, w);
      
      // Flow curve at bottom
      drawFlowCurve(ctx, w * 0.3, h * 0.7, w * 0.4, w);
      
      // Sparkles
      drawSparkle(ctx, noteX - w * 0.08, noteY - h * 0.25, h * 0.04, purple);
      drawSparkle(ctx, noteX - w * 0.06, noteY - h * 0.32, h * 0.03, cyan);
      drawSparkle(ctx, noteX + w * 0.15, noteY, h * 0.035, cyan);
      
      // App title "TempoFlow" with modern gradient
      ctx.save();
      const titleX = w * 0.48;
      const titleY = h * 0.38;
      
      const textGrad = ctx.createLinearGradient(titleX, titleY - h * 0.1, titleX + w * 0.3, titleY + h * 0.1);
      textGrad.addColorStop(0, '#ffffff');
      textGrad.addColorStop(0.5, '#d0f4ff');
      textGrad.addColorStop(1, '#a8daff');
      
      ctx.fillStyle = textGrad;
      ctx.font = `bold ${h * 0.24}px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      
      ctx.shadowColor = 'rgba(168, 85, 247, 0.6)';
      ctx.shadowBlur = 25;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 6;
      
      ctx.fillText('TempoFlow', titleX, titleY);
      ctx.restore();
      
      // Tagline with gradient
      ctx.save();
      const tagGrad = ctx.createLinearGradient(titleX, 0, titleX + w * 0.4, 0);
      tagGrad.addColorStop(0, '#c4f0ff');
      tagGrad.addColorStop(0.6, '#ddb3ff');
      tagGrad.addColorStop(1, '#ffb3d9');
      
      ctx.fillStyle = tagGrad;
      ctx.font = `${h * 0.09}px system-ui, -apple-system, sans-serif`;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('Gesture-Based Metronome for Musicians', titleX, titleY + h * 0.15);
      ctx.restore();
    }
    
    function drawGlossyNote(ctx, x, y, radius, stemHeight, color1, color2) {
      ctx.save();

      // Note head with gradient
      const headGrad = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.4, 0, x, y, radius * 1.5);
      headGrad.addColorStop(0, color2);
      headGrad.addColorStop(0.6, color1);
      headGrad.addColorStop(1, color1 + '99');
      ctx.fillStyle = headGrad;
      
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();

      // Glossy highlight
      const highlightGrad = ctx.createRadialGradient(x - radius * 0.35, y - radius * 0.35, 0, x, y, radius * 0.8);
      highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
      highlightGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
      highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = highlightGrad;
      ctx.beginPath();
      ctx.arc(x - radius * 0.2, y - radius * 0.2, radius * 0.6, 0, Math.PI * 2);
      ctx.fill();

      // Stem with gradient
      const stemGrad = ctx.createLinearGradient(x, y, x, y - stemHeight);
      stemGrad.addColorStop(0, color1);
      stemGrad.addColorStop(1, color2);
      
      ctx.strokeStyle = stemGrad;
      ctx.lineWidth = radius * 0.35;
      ctx.lineCap = 'round';
      ctx.shadowColor = color1;
      ctx.shadowBlur = radius * 0.3;
      
      ctx.beginPath();
      ctx.moveTo(x + radius * 0.85, y - radius * 0.2);
      ctx.lineTo(x + radius * 0.85, y - stemHeight);
      ctx.stroke();

      ctx.restore();
    }

    function drawMetronomeStick(ctx, x, y, length, w) {
      ctx.save();
      
      ctx.translate(x, y);
      ctx.rotate(Math.PI / 5);

      // Stick body with gradient
      const stickGrad = ctx.createLinearGradient(0, -length, 0, length * 0.3);
      stickGrad.addColorStop(0, '#d0f4ff');
      stickGrad.addColorStop(0.5, cyan);
      stickGrad.addColorStop(1, '#7dd3fc');
      
      ctx.fillStyle = stickGrad;
      ctx.shadowColor = cyan;
      ctx.shadowBlur = w * 0.01;
      roundRect(ctx, -w * 0.012, -length, w * 0.024, length * 1.2, w * 0.008, true, false);

      // Handle/top
      const handleGrad = ctx.createRadialGradient(0, -length, 0, 0, -length, w * 0.025);
      handleGrad.addColorStop(0, '#ffffff');
      handleGrad.addColorStop(0.6, '#e0f2fe');
      handleGrad.addColorStop(1, cyan);
      ctx.fillStyle = handleGrad;
      ctx.beginPath();
      ctx.arc(0, -length, w * 0.02, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawFlowCurve(ctx, cx, cy, width, w) {
      ctx.save();
      
      const startX = cx - width / 2;
      const endX = cx + width / 2;
      
      // Multiple curved lines with gradient
      for (let i = 0; i < 3; i++) {
        const yOffset = i * w * 0.008;
        const grad = ctx.createLinearGradient(startX, cy, endX, cy);
        grad.addColorStop(0, pink);
        grad.addColorStop(0.5, purple);
        grad.addColorStop(1, cyan);
        
        ctx.strokeStyle = grad;
        ctx.lineWidth = w * 0.015 - i * w * 0.003;
        ctx.lineCap = 'round';
        ctx.shadowColor = purple;
        ctx.shadowBlur = w * 0.01;
        
        ctx.beginPath();
        ctx.moveTo(startX, cy + yOffset);
        ctx.bezierCurveTo(
          startX + width * 0.3, cy - w * 0.02 + yOffset,
          startX + width * 0.7, cy + w * 0.02 + yOffset,
          endX, cy + yOffset
        );
        ctx.stroke();
      }

      // Dots along the curve
      const dotCount = 5;
      for (let i = 0; i < dotCount; i++) {
        const t = i / (dotCount - 1);
        const x = startX + width * t;
        const curveY = cy + Math.sin(t * Math.PI) * w * 0.015;
        
        const dotGrad = ctx.createRadialGradient(x, curveY, 0, x, curveY, w * 0.012);
        dotGrad.addColorStop(0, '#ffffff');
        dotGrad.addColorStop(0.5, cyan);
        dotGrad.addColorStop(1, cyan + '00');
        
        ctx.fillStyle = dotGrad;
        ctx.shadowColor = cyan;
        ctx.shadowBlur = w * 0.01;
        ctx.beginPath();
        ctx.arc(x, curveY, w * 0.008, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawSparkle(ctx, x, y, size, color) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = size * 0.25;
      ctx.lineCap = 'round';
      ctx.shadowColor = color;
      ctx.shadowBlur = size;
      
      // Vertical line
      ctx.beginPath();
      ctx.moveTo(x, y - size);
      ctx.lineTo(x, y + size);
      ctx.stroke();
      
      // Horizontal line
      ctx.beginPath();
      ctx.moveTo(x - size * 0.7, y);
      ctx.lineTo(x + size * 0.7, y);
      ctx.stroke();
      
      ctx.restore();
    }

    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof radius === 'number') {
        radius = { tl: radius, tr: radius, br: radius, bl: radius };
      } else {
        radius = { tl: radius.tl || 0, tr: radius.tr || 0, br: radius.br || 0, bl: radius.bl || 0 };
      }
      ctx.beginPath();
      ctx.moveTo(x + radius.tl, y);
      ctx.lineTo(x + width - radius.tr, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
      ctx.lineTo(x + width, y + height - radius.br);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
      ctx.lineTo(x + radius.bl, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
      ctx.lineTo(x, y + radius.tl);
      ctx.quadraticCurveTo(x, y, x + radius.tl, y);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }
    
    // Draw the graphic
    drawFeatureGraphic();
    
    // Download function
    function downloadCanvas(canvas, filename) {
      canvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }, 'image/png');
    }
    
    document.getElementById('download').addEventListener('click', () => {
      downloadCanvas(canvas, 'tempoflow-feature-graphic-1024x500.png');
    });
  </script>
</body>
</html>
