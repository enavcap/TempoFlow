<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Generate TempoFlow Icon</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #1a1a1a;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    #canvas {
      border: 2px solid #008080;
      background: transparent;
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      background: #008080;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    button:hover {
      background: #00a0a0;
    }
    .preview {
      display: flex;
      gap: 20px;
      align-items: center;
    }
    .size-label {
      font-size: 12px;
      color: #888;
    }
  </style>
</head>
<body>
  <h1>TempoFlow Icon Generator</h1>
  <canvas id="canvas" width="512" height="512"></canvas>
  
  <div class="preview">
    <div>
      <div class="size-label">48x48</div>
      <canvas id="preview-48" width="48" height="48"></canvas>
    </div>
    <div>
      <div class="size-label">192x192</div>
      <canvas id="preview-192" width="192" height="192"></canvas>
    </div>
  </div>
  
  <button id="download">Download 512x512 PNG for Google Play</button>
  <button id="download-192">Download 192x192 PNG</button>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const preview48 = document.getElementById('preview-48');
    const preview192 = document.getElementById('preview-192');

    // Modern gradient colors
    const bgDark = '#1e1e2e';
    const purple = '#a855f7';
    const cyan = '#06b6d4';
    const pink = '#ec4899';

    function drawIcon(canvas) {
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      const cx = w / 2;
      const cy = h / 2;
      const r = w * 0.42;

      // Dark rounded square background
      const cornerRadius = w * 0.22;
      ctx.fillStyle = bgDark;
      roundRect(ctx, w * 0.08, h * 0.08, w * 0.84, h * 0.84, cornerRadius, true, false);

      // Musical note 1 (left, larger)
      const note1X = cx - w * 0.12;
      const note1Y = cy + h * 0.02;
      const note1R = w * 0.09;
      drawGlossyNote(ctx, note1X, note1Y, note1R, w * 0.45, purple, '#e0bbff');

      // Musical note 2 (right, smaller, higher)
      const note2X = cx + w * 0.05;
      const note2Y = cy - h * 0.08;
      const note2R = w * 0.07;
      drawGlossyNote(ctx, note2X, note2Y, note2R, w * 0.35, cyan, '#d0f4ff');

      // Metronome stick/wand with gradient
      drawMetronomeStick(ctx, cx + w * 0.12, cy - h * 0.02, w * 0.28, w);

      // Curved flow line with dots at bottom
      drawFlowCurve(ctx, cx, cy + h * 0.15, w * 0.6, w);

      // Sparkle effects
      drawSparkle(ctx, cx - w * 0.2, cy - h * 0.15, w * 0.04, purple);
      drawSparkle(ctx, cx - w * 0.15, cy - h * 0.22, w * 0.03, cyan);
      drawSparkle(ctx, cx + w * 0.25, cy + h * 0.05, w * 0.035, cyan);
      drawSparkle(ctx, cx + w * 0.28, cy, w * 0.025, purple);
    }

    function drawGlossyNote(ctx, x, y, radius, stemHeight, color1, color2) {
      ctx.save();

      // Note head with gradient
      const headGrad = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.4, 0, x, y, radius * 1.5);
      headGrad.addColorStop(0, color2);
      headGrad.addColorStop(0.6, color1);
      headGrad.addColorStop(1, color1 + '99');
      ctx.fillStyle = headGrad;
      
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();

      // Glossy highlight
      const highlightGrad = ctx.createRadialGradient(x - radius * 0.35, y - radius * 0.35, 0, x, y, radius * 0.8);
      highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
      highlightGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
      highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = highlightGrad;
      ctx.beginPath();
      ctx.arc(x - radius * 0.2, y - radius * 0.2, radius * 0.6, 0, Math.PI * 2);
      ctx.fill();

      // Stem with gradient
      const stemGrad = ctx.createLinearGradient(x, y, x, y - stemHeight);
      stemGrad.addColorStop(0, color1);
      stemGrad.addColorStop(1, color2);
      
      ctx.strokeStyle = stemGrad;
      ctx.lineWidth = radius * 0.35;
      ctx.lineCap = 'round';
      ctx.shadowColor = color1;
      ctx.shadowBlur = radius * 0.3;
      
      ctx.beginPath();
      ctx.moveTo(x + radius * 0.85, y - radius * 0.2);
      ctx.lineTo(x + radius * 0.85, y - stemHeight);
      ctx.stroke();

      ctx.restore();
    }

    function drawMetronomeStick(ctx, x, y, length, w) {
      ctx.save();
      
      ctx.translate(x, y);
      ctx.rotate(Math.PI / 5);

      // Stick body with gradient
      const stickGrad = ctx.createLinearGradient(0, -length, 0, length * 0.3);
      stickGrad.addColorStop(0, '#d0f4ff');
      stickGrad.addColorStop(0.5, cyan);
      stickGrad.addColorStop(1, '#7dd3fc');
      
      ctx.fillStyle = stickGrad;
      ctx.shadowColor = cyan;
      ctx.shadowBlur = w * 0.02;
      roundRect(ctx, -w * 0.025, -length, w * 0.05, length * 1.2, w * 0.015, true, false);

      // Handle/top
      const handleGrad = ctx.createRadialGradient(0, -length, 0, 0, -length, w * 0.05);
      handleGrad.addColorStop(0, '#ffffff');
      handleGrad.addColorStop(0.6, '#e0f2fe');
      handleGrad.addColorStop(1, cyan);
      ctx.fillStyle = handleGrad;
      ctx.beginPath();
      ctx.arc(0, -length, w * 0.04, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawFlowCurve(ctx, cx, cy, width, w) {
      ctx.save();
      
      const startX = cx - width / 2;
      const endX = cx + width / 2;
      
      // Multiple curved lines with gradient
      for (let i = 0; i < 3; i++) {
        const yOffset = i * w * 0.015;
        const grad = ctx.createLinearGradient(startX, cy, endX, cy);
        grad.addColorStop(0, pink);
        grad.addColorStop(0.5, purple);
        grad.addColorStop(1, cyan);
        
        ctx.strokeStyle = grad;
        ctx.lineWidth = w * 0.02 - i * w * 0.005;
        ctx.lineCap = 'round';
        ctx.shadowColor = purple;
        ctx.shadowBlur = w * 0.015;
        
        ctx.beginPath();
        ctx.moveTo(startX, cy + yOffset);
        ctx.bezierCurveTo(
          startX + width * 0.3, cy - w * 0.03 + yOffset,
          startX + width * 0.7, cy + w * 0.03 + yOffset,
          endX, cy + yOffset
        );
        ctx.stroke();
      }

      // Dots along the curve
      const dotCount = 5;
      for (let i = 0; i < dotCount; i++) {
        const t = i / (dotCount - 1);
        const x = startX + width * t;
        const curveY = cy + Math.sin(t * Math.PI) * w * 0.02;
        
        const dotGrad = ctx.createRadialGradient(x, curveY, 0, x, curveY, w * 0.02);
        dotGrad.addColorStop(0, '#ffffff');
        dotGrad.addColorStop(0.5, cyan);
        dotGrad.addColorStop(1, cyan + '00');
        
        ctx.fillStyle = dotGrad;
        ctx.shadowColor = cyan;
        ctx.shadowBlur = w * 0.015;
        ctx.beginPath();
        ctx.arc(x, curveY, w * 0.015, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawSparkle(ctx, x, y, size, color) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = size * 0.25;
      ctx.lineCap = 'round';
      ctx.shadowColor = color;
      ctx.shadowBlur = size;
      
      // Vertical line
      ctx.beginPath();
      ctx.moveTo(x, y - size);
      ctx.lineTo(x, y + size);
      ctx.stroke();
      
      // Horizontal line
      ctx.beginPath();
      ctx.moveTo(x - size * 0.7, y);
      ctx.lineTo(x + size * 0.7, y);
      ctx.stroke();
      
      ctx.restore();
    }

    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof radius === 'number') {
        radius = { tl: radius, tr: radius, br: radius, bl: radius };
      } else {
        radius = { tl: radius.tl || 0, tr: radius.tr || 0, br: radius.br || 0, bl: radius.bl || 0 };
      }
      ctx.beginPath();
      ctx.moveTo(x + radius.tl, y);
      ctx.lineTo(x + width - radius.tr, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
      ctx.lineTo(x + width, y + height - radius.br);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
      ctx.lineTo(x + radius.bl, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
      ctx.lineTo(x, y + radius.tl);
      ctx.quadraticCurveTo(x, y, x + radius.tl, y);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    // Helper: rounded rect path
    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof radius === 'number') {
        radius = { tl: radius, tr: radius, br: radius, bl: radius };
      } else {
        radius = {
          tl: radius.tl || 0,
          tr: radius.tr || 0,
          br: radius.br || 0,
          bl: radius.bl || 0,
        };
      }

      ctx.beginPath();
      ctx.moveTo(x + radius.tl, y);
      ctx.lineTo(x + width - radius.tr, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
      ctx.lineTo(x + width, y + height - radius.br);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
      ctx.lineTo(x + radius.bl, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
      ctx.lineTo(x, y + radius.tl);
      ctx.quadraticCurveTo(x, y, x + radius.tl, y);
      ctx.closePath();

      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    // Draw main icon
    drawIcon(canvas);
    drawIcon(preview48);
    drawIcon(preview192);
    
    // Download function
    function downloadCanvas(canvas, filename) {
      canvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }, 'image/png');
    }
    
    document.getElementById('download').addEventListener('click', () => {
      downloadCanvas(canvas, 'tempoflow-icon-512.png');
    });
    
    document.getElementById('download-192').addEventListener('click', () => {
      downloadCanvas(preview192, 'tempoflow-icon-192.png');
    });
  </script>
</body>
</html>
